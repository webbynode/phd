#! /bin/bash

# Usage: phd [dir] [host name]
#
# eventually, it might be `phd run [app]` if phd gets more sophisticated

source /usr/bin/load_env

if [[ -z "$1" ]]; then
	echo "Usage: phd [application's .git directory] [hostname]"
	exit
fi

PHD_ROOT=/var/webbynode/phd
LOG_DIR=/var/webbynode/log

if [ ! -d $LOG_DIR ]; then
  sudo mkdir -p $LOG_DIR
  sudo chown -R git:www-data $LOG_DIR
fi

dir=$(dirname $1)
host=$3
app_name=$(basename $dir)
base=$host

if [[ ! "$host" =~ "." ]]; then
  base=$host
  host="$host.webbynode.net"
fi

# read .phdrc (for overrides)
if [[ -f ~/.phdrc ]]; then
	source ~/.phdrc
fi

echo ""
echo "----------------------------"
echo "  Webbynode git deployment "
echo "----------------------------"
echo ""

WEB_SERVER="$WEBSERVER_NAME"
WEB_SERVER_ROOT="$WEBSERVER_PATH"

PHD_VIRTUALHOSTS="/var/webbynode/vhosts"
PHD_CONFIG="$WEB_SERVER_ROOT/conf/nginx.conf"

PUSHAND_INSTALL_DIR=~/tmp
SEMAPHORE="/var/webbynode/semaphores/recreate_$app_name"

sudo mkdir -p /var/log/phd
sudo chown -R git:www-data /var/log/phd

if [[ ! "$base" =~ "." ]]; then
  ip=`ifconfig | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}'`
  echo "Setting up DNS..."
  echo ""
  output=`curl -s -X PUT https://manager2.webbynode.com/api/domain.json?ip=$ip\&app_name=$base -d ''`

  if [ "$?" != "0" ]; then
    echo "$output" >> /var/webbynode/log/domain_error.log
    echo "Could not create a domain for your application. Check /var/webbynode/log/domain_error.log for more information."
    exit 1
  fi

  name=`echo "$output" | sed -e 's/[{}]/''/g' | awk -v k="text" '{n=split($0,a,","); for (i=1; i<=n; i++) print a[i]}' | grep "name" | cut -d ':' -f 2 | sed -e 's/"//g'`
  host="$name"
fi

if [[ -f /var/webbynode/mappings/$app_name.conf ]]; then
  app_dns=$(cat /var/webbynode/mappings/$app_name.conf)
  if [[ ! "$app_dns" = "$host" ]]; then
    echo "Application dns entry changed from $app_dns to $host"
    echo "  => Fixing mapping"
    rm /var/webbynode/mappings/$app_name.conf

    echo "  => Removing vHost for $app_dns"
    rm $PHD_VIRTUALHOSTS/$app_dns

    echo ""
  fi
fi

echo "Deploying application $app_name as $host..."

expand_env_template() {
  eval "echo \"`cat $1`\""
}

add_on() {
  echo "  => Installing addon $1"
}

add_on_status() {
  echo "     $1..."
}

add_on_wait() {
  echo "     $1..."
  echo "     This may take a few minutes, please wait..."
}

check_error() {
  if [ "$?" != "0" ]; then
    echo "  -----------------------------------------------------"
    echo "    There was an error $1:"
    echo ""
    cat $LOG_DIR/$2.log | sed 's/^/     /'
    echo ""
    echo "    Please fix this problem and run wn push again."
    echo "  -----------------------------------------------------"
    exit 1
  fi
}

check_installed() {
  installed=n
  output=`dpkg -s $1 2>&1`
  if [ $? == 0 ]; then
    output=`dpkg -s $1 | grep Status: | grep " installed"`
    if [ $? == 0 ]; then
      installed=y
    fi
  fi
}

install_if_needed() {
  check_installed $1

  if [ "$installed" == "n" ]; then
    add_on_wait "Installing $1"
    sudo apt-get install -y -q $1 2>&1 | sed 's/^/     /' > $LOG_DIR/$1-install.log 2>&1

    if [ "$?" != "0" ]; then
      add_on_status "WARNING: There was an error installing $1."
      add_on_status "         Please check $LOG_DIR/$1-install.log for installation logs."
    fi

    if [ ! -z "$2" ]; then
      `$2`
    fi
  fi
}

check_bundler() {
  result=`gem list bundler | grep bundler`
  if [ "$?" != "0" ]; then
    # bundler not installed
    echo "  => Installing Bundler..."
    sudo gem install bundler --pre >> $LOG_DIR/bundler_install.log 2>&1
    sudo gem install bundler >> $LOG_DIR/bundler_install.log 2>&1
  fi

  if [ -f Gemfile ]; then
    echo "  => Bundling gems..."
    unset GIT_DIR && bundle install --without test development > $LOG_DIR/bundler.log 2>&1
    return 1
  fi

  return 0
}

check_and_remove_semaphore() {
  if [[ -f $SEMAPHORE ]]; then
		rm "$SEMAPHORE"

    if [[ -z "$dns_alias" ]]; then
  		echo "     Recreating vhost with no aliases..."
    else
  		echo "     Recreating vhost with aliases: $dns_alias..."
		fi
  fi
}

configure_apache_vhost() {
  if [[ -f "$PHD_VIRTUALHOSTS/$host" ]] && [[ ! -f "$SEMAPHORE" ]]; then
		echo '     Already configured!'
		return 1
	else
	  check_and_remove_semaphore

		PHD_VIRTUALHOST_TEXT="echo \"$PHD_VIRTUALHOST_TEXT\""
		eval "$PHD_VIRTUALHOST_TEXT" > $PHD_VIRTUALHOSTS/$host
		echo "$host" > /var/webbynode/mappings/$app_name.conf
		return 0
	fi
}

configure_nginx_vhost() {
  if [[ -f "$PHD_VIRTUALHOSTS/$host" ]] && [[ ! -f "$SEMAPHORE" ]]; then
		echo '     Already configured!'
		return 1
	else
	  check_and_remove_semaphore

		PHD_VIRTUALHOST_TEXT="echo \"$PHD_VIRTUALHOST_TEXT\""
		eval "$PHD_VIRTUALHOST_TEXT" > $PHD_VIRTUALHOSTS/$host
		echo "$host" > /var/webbynode/mappings/$app_name.conf
		return 0
	fi
}

configure_vhost() {
  echo "  => Configuring $WEB_SERVER vHost..."

  # handles wildcards
  wildcard=0
  if [[ "$host" =~ ^\*\. ]]; then
    echo "     Setting up wildcard alias..."
    dns_alias=$host
    host=${host#*.}
    wildcard=1
  fi

  if [[ "$WEB_SERVER" == "nginx" ]]; then
    configure_nginx_vhost
  else
    configure_apache_vhost
  fi

  if [ $wildcard == 1 ]; then
    host=$dns_alias
  fi

  return $?
}

restart_webserver() {
  echo ""
  if [[ "$1" == "1" ]]; then
    echo "Restarting passenger..."
    mkdir -p $dir/tmp
    touch $dir/tmp/restart.txt > $LOG_DIR/passenger_restart.log 2>&1
  else
    echo "Restarting $WEB_SERVER"
    if [[ "$WEB_SERVER" == "apache" ]]; then
      sudo /etc/init.d/apache2 restart > $LOG_DIR/apache2_restart.log 2>&1
    else
      sudo /etc/init.d/nginx stop  > $LOG_DIR/nginx_stop.log 2>&1
      sleep 2
      sudo /etc/init.d/nginx start > $LOG_DIR/nginx_start.log 2>&1
    fi
  fi
}

handle_procfile() {
  if [ -f $dir/Procfile ]; then
    echo "  => Setting environment variables..."
    cd /var/webbynode/env
    for f in *; do
       if [ ! -d /var/webbynode/env/$f ]; then
          contents=`cat /var/webbynode/env/$f`
          [ -z $contents ] || echo "$f=$(cat /var/webbynode/env/$f)" >> $dir/.env
       fi
    done

    if [ -d /var/webbynode/env/$app_name ]; then
      cd /var/webbynode/env/$app_name
      for f in *; do
         contents=`cat /var/webbbynode/env/$app_name/$f`
         [ -s /var/webbynode/env/$app_name/$f ]] || [ -z $contents ] || echo "$f=$(cat /var/webbynode/env/$app_name/$f)" >> $dir/.env
      done
    fi

    echo "  => Stopping application..."
    sudo stop $app_name > /dev/null 2>&1

    echo "  => Setting up processes..."
    cd $dir
    sudo foreman export upstart /etc/init -a "$app_name" -u git

    echo "  => Starting processes..."
    sudo start $app_name
  fi
}

function rake_task_defined {
  old_dir=$PWD
  cd $dir
  bundle exec rake $1 --dry-run >/dev/null 2>&1
  cd $old_dir
}

handle_assets_precompile() {
  if rake_task_defined "assets:precompile"; then
    echo "  => Precompiling assets..."
    bundle exec rake assets:precompile RAILS_GROUPS=assets RAILS_ENV=production > $LOG_DIR/assets_precompile.log 2>&1
    check_error 'precompiling assets' 'assets_precompile'
  fi
}

if [[ -f "$dir/.webbynode/settings" ]]; then
  vars=`cat $dir/.webbynode/settings`
  eval $vars
fi

echo ""

if [ -z "$allow_root" ]; then
  if grep -q "PermitRootLogin yes" /etc/ssh/sshd_config; then
    sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config_backup
    echo ""
    echo "Security: Preventing root login..."
    echo ""
    echo "----------------------------------------------------------------"
    echo " "
    echo " IMPORTANT: Rapp will now disable password-based root SSH "
    echo "            login access by default. "
    echo ""
    echo " If you want to access your Webby using root and public key"
    echo " authentication, follow this steps: "
    echo ""
    echo " 1. Make sure you have the latest gem version (1.0.4.2)"
    echo " "
    echo '    $ wn version'
    echo '    [Webbynode] Rapid Deployment Gem v1.0.4.2'
    echo ""
    echo " 2. If needed, update your gem"
    echo ""
    echo '    $ gem install webbynode'
    echo ""
    echo ' 3. Run the authroot command'
    echo ""
    echo '    $ wn authroot'
    echo "    Your local SSH Key has been added to your Webby's root user"
    echo " "
    echo " Now you'll be able to log into your Webby as root without"
    echo " typing a password."
    echo " "
    echo "----------------------------------------------------------------"
    echo ""
    sudo sed -i 's|PermitRootLogin yes|PermitRootLogin without-password|g' /etc/ssh/sshd_config
    sudo /etc/init.d/ssh restart > $LOG_DIR/ssh_restart.log 2>&1
  fi

  if grep -q "PermitRootLogin no" /etc/ssh/sshd_config; then
    sudo sed -i 's|PermitRootLogin no|PermitRootLogin without-password|g' /etc/ssh/sshd_config
    sudo /etc/init.d/ssh restart > $LOG_DIR/ssh_restart.log 2>&1
  fi
else
  if grep -q "PermitRootLogin no" /etc/ssh/sshd_config; then
    sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config_backup
    echo "Security: Allowing root login..."
    echo ""
    sudo sed -i 's|PermitRootLogin no|PermitRootLogin yes|g' /etc/ssh/sshd_config
    sudo sed -i 's|PermitRootLogin without-password|PermitRootLogin yes|g' /etc/ssh/sshd_config
    sudo /etc/init.d/ssh restart > $LOG_DIR/ssh_restart.log 2>&1
  fi
fi

if [[ ! -z "addons" ]]; then
  echo "Configuring addons..."

  for addon in ${addons[@]}; do
    if [[ ! -f "$PHD_ROOT/scripts/addons/$addon.sh" ]]; then
      echo "WARNING: Missing support for addon: $addon. Skipping"
    else
      . $PHD_ROOT/scripts/addons/$addon.sh
    fi
  done

  echo ""
fi

if [[ ! -z "$engine" ]]; then
  if [[ ! -f "$PHD_ROOT/scripts/$engine.sh" ]]; then
    echo "Missing support for engine: $engine. Aborting."
    exit
  else
    . $PHD_ROOT/scripts/$engine.sh
  fi
else
  if [[ -d "$dir/app" && -d "$dir/app/controllers" && -f "$dir/config/environment.rb" ]]; then
    . $PHD_ROOT/scripts/rails.sh
  elif [[ -f "$dir/config.ru" ]]; then
    . $PHD_ROOT/scripts/rack.sh
  else
    echo "WARNING: Didn't detect what application engine you're using."
  fi
fi

echo ""
echo "$app_name deployed successfully."
if [[ ! "$base" =~ "." ]]; then
  echo ""
  echo "Created http://$host/"
fi
echo ""
